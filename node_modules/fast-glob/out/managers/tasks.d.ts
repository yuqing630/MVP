import { Pattern, PatternsGroup } from '../types/patterns';
import { IOptions } from './options';
export interface ITask {
    base: string;
    patterns: Pattern[];
    positive: Pattern[];
    negative: Pattern[];
}
export declare type TaskGroup = Record<string, ITask>;
/**
 * Returns grouped patterns by base directory of each pattern.
 */
export declare function groupPatternsByParentDirectory(patterns: Pattern[]): PatternsGroup;
/**
 * Convert positive patterns to tasks.
 */
export declare function makePositiveTaskGroup(positive: PatternsGroup): TaskGroup;
/**
 * Convert negative patterns to tasks.
 */
export declare function makeNegativeTaskGroup(negative: PatternsGroup): TaskGroup;
/**
 * Returns merged positive and negative task groups.
 *
 * Just two rules:
 *   - If a positive task group has a pair in the negative group, then merge it.
 *   - If a negative task group has a global base task, then merge them to full positive group.
 */
export declare function mergeTaskGroups(positive: TaskGroup, negative: TaskGroup): TaskGroup;
/**
 * Returns builded tasks for provided patterns groups.
 */
export declare function makeTasks(positive: PatternsGroup, negative: PatternsGroup): ITask[];
/**
 * Generate tasks for provided patterns based on base directory of each pattern.
 */
export declare function generate(patterns: Pattern[], options: IOptions): ITask[];
